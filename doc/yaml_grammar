stream ::= stream_begin directives documents stream_end

# TODO:  how does a stream begin?  encoding information?
stream_begin ::= lambda

# TODO:  how does a stream end?
stream_end ::= lambda

directives ::= directive directives
             | lambda

directive ::= version_directive
            | tag_directive

version_directive ::= "%YAML" version_specification

version_specification ::= digit "." digit

digit ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

tag_directive ::= "%TAG" handle uri

# documents may be delimited, but don't always have to be.  for example, the
# first document may start immediately with nodes rather than with a leading
# start-of-document mark.
documents ::= delimited_documents
            | headerless_document delimited_documents footerless_document
            | headerless_document delimited_documents
            | delimited_documents footerless_document

delimited_documents ::= delimited_document delimited_documents
                      | lambda

delimited_document ::= document_begin nodes document_end

headerless_document ::= nodes newline document_end

footerless_document ::= document_begin newline nodes

document_begin ::= "---"

document_end ::= "..."

nodes ::= lambda
        | node nodes

node ::= scalar
       | sequence
       | mapping
       | anchor
       | alias

scalar ::= string
        | null
        | tag string

string ::= [^!\n][^\n]*
         | lambda

null ::= "null"

tag ::= "!" local_tag
     | "!!" standard_tag
     | "!" handle "!" local_tag
     | "tag:" uri ":" local_tag

local_tag ::= [a-zA-Z_]+

standard_tag ::= "str"

handle ::= [a-zA-Z_]+

# TODO:  define grammar for standard URIs.  e.g., yaml.org,2002:
uri ::= lambda

sequence ::= flow_sequence
           | block_sequence

flow_sequence ::= flow_sequence_start aws node aws suffix_listed_nodes aws flow_sequence_end
                | flow_sequence_start aws flow_sequence_end

flow_sequence_start ::= "["

flow_sequence_end ::= "]"

suffix_listed_nodes ::= "," aws node aws suffix_listed_nodes
                      | lambda

# a single whitespace character.  wsc stands for whitespace_character;  i
# chose this short name so i can easily use this production frequently.
wsc ::= space
      | tab
      | newline

# whitespace of arbitrary length (or no whitespace at all). i chose this short
# name so i can easily use this production frequently.
aws ::= ws
     | lambda

# one or more whitespace characters
ws ::= wsc aws

# block sequence defines a sequence of elements of some kind, each in a line
block_sequence ::= block_sequence_element aws
                 | block_sequence_element aws block_sequence

block_sequence_element ::= block_sequence_element_start node newline

block_sequence_element_start ::= "-" aws

mapping ::= flow_mapping
          | block_mapping

flow_mapping ::= flow_mapping_start key aws pair_separator aws node aws suffix_listed_pairs aws flow_mapping_end
               | flow_mapping_start aws flow_mapping_end

flow_mapping_start ::= "{" aws

flow_mapping_end ::= "}" aws

suffix_listed_pairs ::= "," aws key aws pair_separator aws suffix_listed_pairs
                      | lambda

key ::= scalar
      | complex_mapping_key

# block mapping defines a mapping of elements of some kind, each in a line
block_mapping ::= block_mapping_element aws
                | block_mapping_element aws block_mapping

block_mapping_element ::= key pair_separator node newline

pair_separator ::= ":" ws

# a complex mapping key is a key of arbitrary type.  this as opposed to regular
# keys, which must be scalars.
complex_mapping_key ::= complex_mapping_key_symbol node

complex_mapping_key_symbol ::= "?" ws

# anchors name a node so that it can later be referenced by its name (see
# alias)
anchor ::= anchor_symbol string node

anchor_symbol ::= "&"

# aliases are the names given to a node earlier by an anchor (see anchor)
alias ::= alias_symbol string

alias_symbol ::= "*"
