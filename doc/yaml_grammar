stream ::= stream_begin directives documents stream_end

# TODO:  how does a stream begin?  encoding information?
stream_begin ::= lambda

# TODO:  how does a stream end?
stream_end ::= lambda

directives ::= directive directives
             | lambda

directive ::= version_directive
            | tag_directive

version_directive ::= version_directive_symbol version_specification

version_directive_symbol ::= "%YAML"

version_specification ::= integer
                        | integer version_component_separator version_specification

integer ::= digit
          | digit integer

digit ::= "0" | "1" | ... | "9"

version_component_separator ::= "."

tag_directive ::= tag_directive_symbol handle uri

tag_directive_symbol ::= "%TAG"

# documents may be delimited, but don't always have to be.  for example, the
# first document may start immediately with nodes rather than with a leading
# start-of-document mark.
documents ::= delimited_documents
            | headerless_document delimited_documents footerless_document
            | headerless_document delimited_documents
            | delimited_documents footerless_document

delimited_documents ::= delimited_document delimited_documents
                      | lambda

delimited_document ::= document_begin nodes document_end

headerless_document ::= nodes newline document_end

footerless_document ::= document_begin newline nodes

document_begin ::= "---"

document_end ::= "..."

nodes ::= lambda
        | node nodes

node ::= scalar
       | sequence
       | mapping
       | anchor
       | alias

scalar ::= string
        | literal_style
        | folded_style
        | null
        | tag string

string ::= [^!] text

# string scalars can have newlines, but newlines are never significant.  they
# are always folded into single space characters.
text ::= any_character_newline_included_until_end_of_scope_as_determined_by_indentation

literal_style ::= literal_style_symbol literal_style_text

literal_style_symbol ::= "|" aws

literal_style_text ::= string
                     | string literal_style_text

# TODO:  folded style.  see section 2.3 in the standard
folded_style ::= lambda

null ::= "null"
       | "Null"
       | "NULL"
       | "~"

tag ::= "!" local_tag
      | "!!" standard_tag
      | "!" handle "!" local_tag
      | "tag:" uri ":" local_tag

local_tag ::= [a-zA-Z_]+

standard_tag ::= "str"

handle ::= [a-zA-Z_]+

# TODO:  define grammar for standard URIs.  e.g., yaml.org,2002:
uri ::= lambda

sequence ::= flow_sequence
           | block_sequence

flow_sequence ::= flow_sequence_start aws node aws suffix_listed_nodes aws flow_sequence_end
                | flow_sequence_start aws flow_sequence_end

flow_sequence_start ::= "[" aws

# the "aws_but_no_newline newline aws" trick is just to make sure there's a
# newline
flow_sequence_end ::= "]" aws_but_no_newline newline aws

suffix_listed_nodes ::= "," aws node aws suffix_listed_nodes
                      | lambda

# a single whitespace character.  wsc stands for whitespace_character;  i
# chose this short name so i can easily use this production frequently.
wsc ::= space
      | tab
      | newline

# whitespace of arbitrary length (or no whitespace at all). i chose this short
# name so i can easily use this production frequently.
aws ::= ws
     | lambda

# one or more whitespace characters
ws ::= wsc aws

# block sequence defines a sequence of elements of some kind, each in a line
block_sequence ::= block_sequence_element aws
                 | block_sequence_element aws block_sequence

block_sequence_element ::= block_sequence_element_start node newline

block_sequence_element_start ::= "-" aws

mapping ::= flow_mapping
          | block_mapping

flow_mapping ::= flow_mapping_start key aws pair_separator aws node aws suffix_listed_pairs aws flow_mapping_end newline
               | flow_mapping_start aws flow_mapping_end newline

flow_mapping_start ::= "{" aws

# the "aws_but_no_newline newline aws" trick is just to make sure there's a
# newline
flow_mapping_end ::= "}" aws_but_no_newline newline aws

suffix_listed_pairs ::= "," aws key aws pair_separator aws suffix_listed_pairs
                      | lambda

key ::= scalar
      | complex_mapping_key

# block mapping defines a mapping of elements of some kind, each in a line
block_mapping ::= block_mapping_element aws
                | block_mapping_element aws block_mapping

block_mapping_element ::= key pair_separator node newline

pair_separator ::= ":" ws

# a complex mapping key is a key of arbitrary type.  this as opposed to regular
# keys, which must be scalars.
complex_mapping_key ::= complex_mapping_key_symbol node

complex_mapping_key_symbol ::= "?" ws

# anchors name a node so that it can later be referenced by its name (see
# alias)
anchor ::= anchor_symbol identifier node

identifier ::= identifier_prefix identifier_suffix

identifier_prefix ::= "_"
                    | lowercase_letter
                    | uppercase_letter

identifier_suffix ::= lambda
                    | identifier_suffix_character identifier_suffix

identifier_suffix_character ::= "_"
                              | lowercase_letter
                              | uppercase_letter
                              | digit

anchor_symbol ::= "&"

# aliases are the names given to a node earlier by an anchor (see anchor)
alias ::= alias_symbol string

alias_symbol ::= "*"
