\documentclass[12pt,letterpaper]{article}

\usepackage{pxfonts}
\usepackage{url}
\usepackage{float}

\author{Alex Vall\'ee \and Matan Nassau}
\title{libyaml++:  A Proposal for a COMP 446 Project}

\begin{document}

\maketitle

\section{Introduction}
For our COMP 446 project we chose to write a C++ library for reading and writing \emph{YAML} streams.  YAML stands for \emph{YAML Ain't a Markup Language}.  It is a portable data-serialization protocol, designed primarily for readability by humans.  YAML plays well as a protocol for message-based distributed processing systems.

YAML is somewhat comparable with XML in that it can be used as a protocol for serializing structured, hierarchical documents.  XML, however, was designed to be backwards-compatible with \emph{SGML}, the \emph{Standard Generalized Markup Language}, which in turn was designed primarily to store structured documents.  YAML therefore has more freedom of design.  When compared to XML, YAML elevates its design goals to support data streams that show a balance between a flexible syntax and readability.

\floatstyle{ruled}
\newfloat{Figure}{h}{yamlsample}[section]
\begin{Figure}
  \begin{verbatim}
  ---
  - name:  Richard Stallman
    email: rms@gnu.org
  - name:  Linus Torvalds
    email: torvalds@linux-foundation.org
  - name:  Jeff Atwood
    email: jatwood@codinghorror.com
  \end{verbatim}
  \caption{Sample YAML data}
\end{Figure}

\section{Goals}

The goal of this project is to write a YAML library for C++ consisting of a useful subset of the YAML 1.2 specification.  We lay our priorities in decreasing order as follows:

\begin{enumerate}
  \item \textbf{Correct}.  We consider our code correct if each implemented feature works as described by version 1.2 of the YAML standard.  We will utilize aggressive testing for this purpose.
  \item \textbf{Useful}.  We chose a number of key components of the YAML specification in order to deliver a useful, albeit partial, YAML implementation:
    \begin{itemize}
      \item Scalars
      \item Sequences
      \item Mappings
    \end{itemize}
    Of the standard YAML scalar types, we will implement strings.
  \item \textbf{Quality code}.  Finally, we will design and implement our library such that it is as easy as possible to implement the rest of the YAML 1.2 standard later on.
\end{enumerate}

\section{C++ Use}

In this project, we expect to use a broad array of C++ techniques and features appropriate for library writing:

\begin{itemize}
  \item Templates and meta-programming
  \item Inheritance and polymorphism
  \item Various design patterns, such as factory method, singleton and so on.
  \item Massive use of the STL containers and algorithms
  \item Some TR1 elements, such as \emph{tr1::shared\_ptr}
  \item Unit-testing framework:  \emph{Google Test}
\end{itemize}

We will also use \emph{waf} for our build system, and \emph{git} for our version control system.

\section{Deliverables}

The following is a rough outline of our planned iterations:

\begin{enumerate}
  \item Begin/End document marks
  \item Comments
  \item Simple Scalars
  \item Sequences
  \item Simple Mappings
  \item Tagged nodes
  \item Untagged nodes (type resolution on runtime)
  \item Verbatim, Folded Scalars
  \item Complex Mappings
  \item Unicode support
\end{enumerate}

The above list probably includes more iterations than time permits.  Nevertheless, these encompass a reasonable portion of YAML standard and lay a rough roadmap for an implementation.
\end{document}
